/*******************************************************************************
 * Copyright (c) 2007-2010 Dennis Wagelaar, Vrije Universiteit Brussel.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Dennis Wagelaar, Vrije Universiteit Brussel
 *******************************************************************************/
package be.ac.vub.jar2uml;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.uml2.uml.Classifier;
import org.eclipse.uml2.uml.Feature;
import org.eclipse.uml2.uml.Model;
import org.eclipse.uml2.uml.NamedElement;
import org.eclipse.uml2.uml.Namespace;
import org.eclipse.uml2.uml.Package;

/**
 * Merges two models generated by {@link JarToUML}.
 * @author Dennis Wagelaar <dennis.wagelaar@vub.ac.be>
 */
public final class MergeModel extends JarToUMLRunnable {

	private static final int WORK_FIND_CONTAINED = 100;
	private static final int WORK_MERGE_CLASSES = 100;
	private static final int WORK_INFERRED_TAGS = 100;
	private static final int WORK_TOTAL = WORK_FIND_CONTAINED + WORK_MERGE_CLASSES + WORK_INFERRED_TAGS;

	/**
	 * @param e
	 * @return the Java qualified name of c
	 */
	public static String getJavaName(NamedElement e) {
		final StringBuffer jn = new StringBuffer();
		final Namespace ns = e.getNamespace();
		if (ns != null && ns.getNamespace() != null) { //skip root element
			jn.append(getJavaName(ns));
			if (e instanceof Feature) {
				assert ns instanceof Classifier;
				jn.append('#');
			} else if (ns instanceof Classifier) {
				assert e instanceof Classifier;
				jn.append('$');
			} else {
				assert ns instanceof Package || ns instanceof Feature;
				jn.append('.');
			}
		}
		jn.append(e.getName());
		return jn.toString();
	}

	/**
	 * Finds all {@link Classifier}s contained in ns and adds them to classifiers.
	 * @param ns
	 * @param classifiers
	 */
	public static void findClassifiers(final Namespace ns, final Collection<Classifier> classifiers) {
		for (NamedElement e : ns.getOwnedMembers()) {
			if (e instanceof Package) {
				findClassifiers((Namespace) e, classifiers);
			} else if (e instanceof Classifier) {
				classifiers.add((Classifier) e);
				findClassifiers((Namespace) e, classifiers);
			}
		}
	}

	private Model baseModel;
	private Model mergeModel;

	/**
	 * Performs the actual merge.
	 */
	protected void runWithMonitor(final IProgressMonitor monitor) {
		final Model base = getBaseModel();
		final Model merge = getMergeModel();
		assert base != null;
		assert merge != null;
		beginTask(monitor, String.format(
				JarToUMLResources.getString("MergeModel.startingFor"),
				merge, base), WORK_TOTAL); //$NON-NLS-1$
		final StringBuffer baseName = new StringBuffer();
		if (base.getName() != null) {
			baseName.append(base.getName());
			baseName.append(" + "); //$NON-NLS-1$
		}
		baseName.append(merge.getName());
		base.setName(baseName.toString()); //$NON-NLS-1$
		//
		// 1
		//
		subTask(monitor, JarToUMLResources.getString("MergeModel.findingContained")); //$NON-NLS-1$
		final List<Classifier> baseElements = new ArrayList<Classifier>();
		final List<Classifier> mergeElements = new ArrayList<Classifier>();
		findClassifiers(base, baseElements);
		findClassifiers(merge, mergeElements);
		IProgressMonitor containedMon = null;
		if (monitor != null) {
			containedMon = new SubProgressMonitor(monitor, WORK_FIND_CONTAINED);
			containedMon.beginTask(
					JarToUMLResources.getString("MergeModel.findingContained"), 
					baseElements.size());
		}
		final MergeClassifiers mergeClassifiers = new MergeClassifiers(
				null, monitor, WORK_MERGE_CLASSES, base, true, false);
		findContainedClassifiersIn(containedMon, baseElements, mergeClassifiers.getContainedClassifiers());
		worked(null, JarToUMLResources.getString("MergeModel.foundContained")); //$NON-NLS-1$
		//
		// 2
		//
		subTask(monitor, JarToUMLResources.getString("MergeModel.mergingClassifiers")); //$NON-NLS-1$
		mergeClassifiers.beginTask(
				JarToUMLResources.getString("MergeModel.mergingClassifiers"), 
				mergeElements.size()); //$NON-NLS-1$
		mergeClassifiers.mergeAllClassifiers(mergeElements);
		worked(null, JarToUMLResources.getString("MergeModel.mergedClassifiers")); //$NON-NLS-1$
		//
		// 3
		//
		subTask(monitor, JarToUMLResources.getString("MergeModel.updatingInferred")); //$NON-NLS-1$
		final MarkInferredClassifiers markInferredClassifiers = new MarkInferredClassifiers(
				null, monitor, WORK_INFERRED_TAGS, base);
		markInferredClassifiers.addAllInferredTags(mergeClassifiers.getContainedClassifiers());
		worked(monitor, JarToUMLResources.getString("MergeModel.updatedInferred")); //$NON-NLS-1$
	}

	/**
	 * Finds non-inferred (contained) {@link Classifier}s in elements and stores them in containedClassifiers.
	 * @param monitor the progress monitor to increase on every element
	 * @param elements
	 * @param containedClassifiers
	 */
	private void findContainedClassifiersIn(
			final IProgressMonitor monitor,
			final List<Classifier> elements, 
			final Collection<Classifier> containedClassifiers) {
		for (Classifier c : elements) {
			if (!AddInferredTagSwitch.isInferred(c)) {
				containedClassifiers.add(c);
			}
			worked(monitor, null);
		}
		done(monitor, null);
	}

	/**
	 * @return the baseModel
	 */
	public Model getBaseModel() {
		return baseModel;
	}

	/**
	 * @param baseModel the baseModel to set
	 */
	public void setBaseModel(Model baseModel) {
		this.baseModel = baseModel;
	}

	/**
	 * @return the mergeModel
	 */
	public Model getMergeModel() {
		return mergeModel;
	}

	/**
	 * @param mergeModel the mergeModel to set
	 */
	public void setMergeModel(Model mergeModel) {
		this.mergeModel = mergeModel;
	}

}
