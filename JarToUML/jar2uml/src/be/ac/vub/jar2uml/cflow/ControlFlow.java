/*******************************************************************************
 * Copyright (c) 2007-2010 Dennis Wagelaar, Vrije Universiteit Brussel.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Dennis Wagelaar, Vrije Universiteit Brussel
 *******************************************************************************/
package be.ac.vub.jar2uml.cflow;

import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;

import org.apache.bcel.Constants;
import org.apache.bcel.classfile.Code;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.generic.ATHROW;
import org.apache.bcel.generic.EmptyVisitor;
import org.apache.bcel.generic.ExceptionThrower;
import org.apache.bcel.generic.GotoInstruction;
import org.apache.bcel.generic.IFNONNULL;
import org.apache.bcel.generic.IFNULL;
import org.apache.bcel.generic.IfInstruction;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.JsrInstruction;
import org.apache.bcel.generic.MethodGen;
import org.apache.bcel.generic.ObjectType;
import org.apache.bcel.generic.RET;
import org.apache.bcel.generic.ReturnInstruction;
import org.apache.bcel.generic.ReturnaddressType;
import org.apache.bcel.generic.Select;
import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.Visitor;
import org.apache.bcel.verifier.structurals.ExceptionHandler;
import org.apache.bcel.verifier.structurals.ExceptionHandlers;
import org.apache.bcel.verifier.structurals.Frame;
import org.apache.bcel.verifier.structurals.LocalVariables;
import org.apache.bcel.verifier.structurals.UninitializedObjectType;

import be.ac.vub.jar2uml.cflow.LocalHistoryTable.OrderedItem;

/**
 * A control flow simulator for BCEL {@link MethodGen} code. 
 * @author Dennis Wagelaar <dennis.wagelaar@vub.ac.be>
 */
public class ControlFlow {

	/**
	 * Represents the control flow information of an {@link InstructionHandle}. 
	 * @author Dennis Wagelaar <dennis.wagelaar@vub.ac.be>
	 */
	public class InstructionFlow implements OrderedItem {
		
		private class InstructionSuccessorVisitor extends EmptyVisitor {
			
			private final Frame frame;

			private InstructionHandle[] successors = new InstructionHandle[] {
					getInstruction().getNext()
			};

			/**
			 * Creates a new {@link InstructionSuccessorVisitor}.
			 * @param frame
			 */
			public InstructionSuccessorVisitor(final Frame frame) {
				this.frame = frame;
			}

			/**
			 * @param successors the successors to set
			 */
			protected void setSuccessors(InstructionHandle[] successors) {
				this.successors = successors;
			}

			/**
			 * @return the successors
			 */
			public InstructionFlow[] getSuccessors() {
				return getFlowOf(successors);
			}

			/**
			 * @return the frame
			 */
			public Frame getFrame() {
				return frame;
			}

			/**
			 * Terminates method abnormally: no successors.
			 * @param obj
			 */
			@Override
			public void visitATHROW(ATHROW obj) {
				setSuccessors(EMPTY);
			}

			/**
			 * Goto target is set as successor.
			 * @param obj
			 */
			@Override
			public void visitGotoInstruction(GotoInstruction obj) {
				setSuccessors(new InstructionHandle[] { obj.getTarget() });
			}

			/**
			 * Two alternative branch targets are set as successors.
			 * @param obj
			 */
			@Override
			public void visitIfInstruction(IfInstruction obj) {
				final InstructionHandle[] ret = new InstructionHandle[2];
				ret[0] = getInstruction().getNext();
				ret[1] = obj.getTarget();
				setSuccessors(ret);
			}

			/*
			 * We may know beforehand which way a IFNULL or IFNONNULL jump goes,
			 * but the Java compiler does not check for this. As a result, there
			 * may be dead code WITHOUT any warnings generated by the compiler!
			 * 
			 * It's ok to be smarter than the compiler here, as dependencies of
			 * dead code can be ignored.
			 * 
			 * If a target of a jump is cut off, this may confuse the search
			 * algorithm, as it doesn't know about the cut off branch! The search
			 * algorithm may decide not to try this instruction anymore, as there
			 * were "no problems" with it! Hence, an exception must be thrown to
			 * indicate the situation!
			 */

			/**
			 * @see #visitIfInstruction(IfInstruction)
			 * @throws BranchTargetUnavailableException if a branch target was cut off due to the given execution frame
			 */
			@Override
			public void visitIFNONNULL(IFNONNULL obj) {
				if (getFrame().getStack().peek().equals(Type.NULL)) {
					//We already know which way the jump goes
					setSuccessors(new InstructionHandle[] { getInstruction().getNext() });
					throw new BranchTargetUnavailableException(getSuccessors());
				} //else jump may still go either way
			}

			/**
			 * @see #visitIfInstruction(IfInstruction)
			 * @throws BranchTargetUnavailableException if a branch target was cut off due to the given execution frame
			 */
			@Override
			public void visitIFNULL(IFNULL obj) {
				if (getFrame().getStack().peek().equals(Type.NULL)) {
					//We already know which way the jump goes
					setSuccessors(new InstructionHandle[] { obj.getTarget() });
					throw new BranchTargetUnavailableException(getSuccessors());
				} //else jump may still go either way
			}

			/**
			 * Jump target is set as successor.
			 * @param obj
			 */
			@Override
			public void visitJsrInstruction(JsrInstruction obj) {
				setSuccessors(new InstructionHandle[] { obj.getTarget() });
			}

			/**
			 * Return target is set as successor.
			 * @param obj
			 * @throws ClassCastException if the given execution frame does not contain a valid return address
			 */
			@Override
			public void visitRET(RET obj) {
				final ReturnaddressType address = (ReturnaddressType) getFrame().getLocals().get(obj.getIndex());
				setSuccessors(new InstructionHandle[]{ address.getTarget() });
			}

			/**
			 * Terminates method normally: no successors.
			 * @param obj
			 */
			@Override
			public void visitReturnInstruction(ReturnInstruction obj) {
				setSuccessors(EMPTY);
			}

			/**
			 * Sets the (unique) collection of switch targets as successors.
			 * @param obj
			 */
			@Override
			public void visitSelect(Select obj) {
				final LinkedHashSet<InstructionHandle> uniqueTargets = new LinkedHashSet<InstructionHandle>();
				//default target
				uniqueTargets.add(obj.getTarget());
				//switch targets
				for (InstructionHandle target : obj.getTargets()) {
					uniqueTargets.add(target);
				}
				final InstructionHandle[] ret = new InstructionHandle[uniqueTargets.size()];
				uniqueTargets.toArray(ret);
				setSuccessors(ret);
			}

		}

		private final InstructionHandle instr;
		private final int index;

		/**
		 * Creates a new {@link InstructionFlow}.
		 * @param instr
		 */
		protected InstructionFlow(InstructionHandle instr) {
			this.instr = instr;
			int counter = 0;
			while (instr.getPrev() != null) {
				instr = instr.getPrev();
				counter++;
			}
			this.index = counter;
			flows[counter] = this;
		}

		/**
		 * @return The exception handlers that protect this instruction
		 * @see ExceptionHandlers#getExceptionHandlers(InstructionHandle)
		 */
		public final ExceptionHandler[] getExceptionHandlers() {
			return getExceptionHandlersObject().getExceptionHandlers(getInstruction());
		}

		/**
		 * @return The represented instruction
		 */
		public InstructionHandle getInstruction() {
			return instr;
		}

		/**
		 * @param frame the execution frame BEFORE execution if this instruction
		 * @return The possible successor instructions for this instruction
		 * @throws BranchTargetUnavailableException if a branch target was cut off due to the given execution frame
		 */
		public final InstructionFlow[] getSuccessors(final Frame frame) {
			final InstructionSuccessorVisitor successors = new InstructionSuccessorVisitor(frame);
			accept(successors);
			return successors.getSuccessors();
		}

		/* (non-Javadoc)
		 * @see java.lang.Object#toString()
		 */
		@Override
		public String toString() {
			return getClass().getSimpleName() + "[" + getIndex() + "]{ " + getInstruction().toString().trim() + " }"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
		}
		
	    /** 
	     * Convenience method, simply calls accept() on the contained instruction.
	     * @param v Visitor object
	     */
		public final void accept(Visitor v) {
			getInstruction().accept(v);
		}

		/**
		 * @return <code>true</code> iff the contained instruction is an {@link ExceptionThrower}.
		 */
		public final boolean isExceptionThrower() {
			return getInstruction().getInstruction() instanceof ExceptionThrower;
		}

		/**
		 * Convenience method that calls getPosition() on the contained instruction.
		 * @return the byte offset position of the contained instruction
		 */
		public final int getPosition() {
			return getInstruction().getPosition();
		}

		/**
		 * @return the list position of the contained instruction
		 */
		public int getIndex() {
			return index;
		}

	}

	private static final InstructionHandle[] EMPTY = new InstructionHandle[0];

	private final MethodGen method;
	private final Frame startFrame;
	private final ExceptionHandlers exceptionHandlers;

	protected final Map<InstructionHandle, InstructionFlow> flowOf = new HashMap<InstructionHandle, InstructionFlow>();
	protected final InstructionFlow[] flows;

	/**
	 * Creates a new {@link ControlFlow}.
	 * @param method
	 */
	public ControlFlow(MethodGen method) {
		super();
		this.method = method;
		final Method m = method.getMethod();
		final Code code = m.getCode();
		this.startFrame = new Frame(code.getMaxLocals(), code.getMaxStack());
		initLocalVariableTypes(startFrame);
		exceptionHandlers = new ExceptionHandlers(method);
		flows = new InstructionFlow[method.getInstructionList().getLength()];
	}
	
	/**
	 * Initialises the local variable types in frame according to the method
	 * context (java class) and argument types.
	 * @param frame
	 */
	private void initLocalVariableTypes(final Frame frame) {
		final MethodGen method = getMethod();
		final LocalVariables localVars = frame.getLocals();
		int i = 0;
		if (!method.isStatic()) {
			final ObjectType objectType = new ObjectType(method.getClassName());
			if (Constants.CONSTRUCTOR_NAME.equals(method.getName())) {
				localVars.set(i, new UninitializedObjectType(objectType));
			} else {
				localVars.set(i, objectType);
			}
			i++;
		}
		for (Type argType : method.getArgumentTypes()) {
			if (argType == Type.BYTE || argType == Type.SHORT || argType == Type.BOOLEAN || argType == Type.CHAR){
				argType = Type.INT;
			}
			localVars.set(i, argType);
			i += argType.getSize();
		}
	}

	/**
	 * @param instr
	 * @return the control flow information for instr
	 */
	public InstructionFlow getFlowOf(InstructionHandle instr) {
		InstructionFlow flow = flowOf.get(instr);
		if (flow == null) {
			flow = new InstructionFlow(instr);
			flowOf.put(instr, flow);
		}
		return flow;
	}

	/**
	 * @param instr
	 * @return the control flow information for instr
	 */
	public InstructionFlow[] getFlowOf(InstructionHandle[] instr) {
		final InstructionFlow[] flowOf = new InstructionFlow[instr.length];
		for (int i = 0; i < instr.length; i++) {
			flowOf[i] = getFlowOf(instr[i]);
		}
		return flowOf;
	}

	/**
	 * @param index
	 * @return the instruction flow with the given index, or <code>null</code>
     * @throws IndexOutOfBoundsException {@inheritDoc}
	 */
	public InstructionFlow getFlow(int index) {
		return flows[index];
	}

	/**
	 * @return the method
	 */
	public MethodGen getMethod() {
		return method;
	}

	/**
	 * @return the startFrame
	 */
	public Frame getStartFrame() {
		return startFrame;
	}

	/**
	 * @return the starting instruction
	 */
	public InstructionFlow getStartInstruction() {
		return getFlowOf(getMethod().getInstructionList().getStart());
	}

	/**
	 * @return the exceptionHandlers
	 */
	public ExceptionHandlers getExceptionHandlersObject() {
		return exceptionHandlers;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return getClass().getSimpleName() + "[" + flows.length + "]{ " + getMethod().toString() + " }"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
	}

}
